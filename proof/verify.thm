Specification "proof".


/********************************************************************
 *                           ASSUMPTIONS                            *
 ********************************************************************/

/*
 * We can't prove anything about not_assigned because it uses cut and
 * fail, so we assume it works.
 */
Theorem not_assigned_true_lit : forall Ctx L,
  {Ctx |- not_assigned L} -> member (is_true L) Ctx -> false.
skip.
Theorem not_assigned_false_lit : forall Ctx L NL,
  {Ctx |- not_assigned L} -> {negate L NL} ->
  member (is_true NL) Ctx -> false.
skip.


/*
 * We can't prove all variables are equal or not because we don't have
 * our variables defined other than for specific problems.  However,
 * they will be simple constants in our uses, so this is clearly going
 * to be true, and thus we assume it.
 *
 * If our vars were defined here, we could define an is relation and
 * prove this.  However, since some problems will require more
 * variables than others, we don't want to define them in general,
 * since we wouldn't always have enough.
 */
Theorem var_eq_or_not : forall (V1 V2 : var),
  V1 = V2 \/ (V1 = V2 -> false).
skip.




/********************************************************************
 *                           IS RELATIONS                           *
 ********************************************************************/

/*
 * Define type relations
 */
Define is_lit : lit -> prop by
  is_lit (var V);
  is_lit (neg V).

Define is_clause : clause -> prop by
  is_clause c*;
  is_clause (or L Rest) := is_lit L /\ is_clause Rest.

Define is_formula : formula -> prop by
  is_formula f*;
  is_formula (and C Rest) := is_clause C /\ is_formula Rest.

Define is_proof : proof -> prop by
  is_proof (p* PL);
  is_proof (add_line C PL AbsRest) :=
    is_clause C /\ nabla x, is_proof (AbsRest x).


Theorem lit_eq_or_not : forall L1 L2,
  is_lit L1 -> is_lit L2 -> (L1 = L2 \/ (L1 = L2 -> false)).
intros Is1 Is2. case Is1.
  %1:  var V
   case Is2.
     %1.1:  var V1
      apply var_eq_or_not with V1 = V, V2 = V1. case H1.
        %1.1.1:  equal
         search.
        %1.1.2:  not equal
         right. intros Eq. case Eq. backchain H2.
     %1.2:  neg V1
      search.
  %2:  neg V
   case Is2.
     %2.1:  var V1
      search.
     %2.2:  neg V1
      apply var_eq_or_not with V1 = V, V2 = V1. case H1.
        %2.2.1:  equal
         search.
        %2.2.2:  not equal
         right. intros Eq. case Eq. backchain H2.




/********************************************************************
 *                          NAME AND NABLA                          *
 ********************************************************************/

Define name : clause_id -> prop by
  nabla x, name x.

Theorem nabla_not_member : forall C L, nabla x,
  member (clause_id x C) L -> false.
induction on 1. intros Mem. case Mem. backchain IH.

/*
 * We need to close some terms so we know nominal constants of one
 * type cannot occur inside others.
 */
Close var, clause_id, lit, clause.




/********************************************************************
 *                          ASSIGN CONTEXT                          *
 ********************************************************************/

/*
 * A good context contains is_true and clause_id
 * A good context contains at most is_true of A or -A, not both
 * A good context contains at most ONE binding for a clause ID
 */
Define assign_context : olist -> prop by
  assign_context nil;
  assign_context (is_true (var V)::Rest) :=
     (member (is_true (neg V)) Rest -> false) /\
     assign_context Rest;
  assign_context (is_true (neg V)::Rest) :=
     (member (is_true (var V)) Rest -> false) /\
     assign_context Rest;
  nabla CID, assign_context (clause_id CID Clause::Rest) :=
     is_clause Clause /\ assign_context Rest.


Theorem assign_context_member : forall Ctx F,
  assign_context Ctx -> member F Ctx ->
  (exists L, is_lit L /\ F = is_true L) \/
  (exists CID C, is_clause C /\ F = clause_id CID C /\ name CID).
induction on 2. intros GC Mem. case Mem.
  %1:  Member here
   case GC.
    %1.1:  F = is_true (neg V)
     search.
    %1.2:  F = is_true (var V)
     search.
    %1.3:  F = clause_id CID Clause
     search.
  %2:  Member later
   case GC.
    %2.1:  First is_true neg
     apply IH to H3 H1. search.
    %2.2:  First is_true var
     apply IH to H3 H1. search.
    %2.3:  First clause_id
     apply IH to H3 H1. search.


Theorem assign_context_not_member_lit_and_neg : forall Ctx L NL,
  assign_context Ctx -> {negate L NL} ->
  member (is_true L) Ctx -> member (is_true NL) Ctx ->
  false.
induction on 1. intros GC Neg MemL MemNL. case GC (keep).
  %1:  nil Ctx
   case MemL.
  %2:  is_true var
   case MemL.
     %2.1:  mem here (L = var V)
      case Neg. case MemNL. backchain H1.
     %2.2:  mem later
      case MemNL.
        %2.2.1:  mem here (NL = var V)
         case Neg (keep). backchain H1.
        %2.2.2:  mem later
         apply IH to H2 Neg H3 H4.
  %3:  is_true neg
   case MemL.
     %3.1:  mem here (L = neg V)
      case Neg. case MemNL. backchain H1.
     %3.2:  mem later
      case MemNL.
        %3.2.1:  mem here (NL = neg V)
         case Neg. backchain H1.
        %3.2.2:  mem later
         backchain IH.
  %4:  clause_id
   case MemL. case MemNL. backchain IH.


Theorem assign_context_add_is_true_not_mem : forall AC L NL,
  assign_context AC -> {negate L NL} ->
  (member (is_true NL) AC -> false) ->
  assign_context (is_true L::AC).
intros AC Neg NotMem. case Neg. search. search.


Theorem assign_context_add_is_true : forall AC L,
  assign_context AC -> is_lit L -> {AC |- not_assigned L} ->
  assign_context (is_true L::AC).
intros AC IsL NA. case IsL.
  %1:  var V
   assert member (is_true (neg V)) AC -> false.
     intros Mem. Neg: assert {negate (var V) (neg V)}.
     apply not_assigned_false_lit to NA Neg Mem.
   search.
  %2:  neg V
   assert member (is_true (var V)) AC -> false.
     intros Mem. Neg: assert {negate (neg V) (var V)}.
     apply not_assigned_false_lit to NA Neg Mem.
   search.


Theorem clause_id_is_clause : forall AC CID C,
  assign_context AC -> {AC |- clause_id CID C} -> is_clause C.
intros AC ClauseID. case ClauseID.
apply assign_context_member to AC H2. case H3.
  %1:  member is_true
   case H1.
  %2:  member clause_id
   case H1. search.


Theorem clause_id_unique : forall AC CID C1 C2,
  assign_context AC -> member (clause_id CID C1) AC ->
  member (clause_id CID C2) AC -> C1 = C2.
induction on 2. intros AC Mem1 Mem2. case Mem1.
  %1:  mem 1 here
   case Mem2.
     %1.1:  mem 2 here
      search.
     %1.2:  mem 2 later
      case AC. apply nabla_not_member to H1.
  %2:  mem 1 later
   case Mem2.
     %2.1:  mem 2 here
      case AC. apply nabla_not_member to H1.
     %2.2:  mem 2 later
      backchain IH with AC = L. case AC. search. search. search.


Theorem assign_context_member_or_not : forall AC L,
  assign_context AC -> is_lit L ->
  (member (is_true L) AC \/ (member (is_true L) AC -> false)).
induction on 1. intros AC IsL. case AC.
  %1:  nil
   right. intros. case H1.
  %2:  member (is_true var)
   apply IH to H2 IsL. case H3.
     %2.1:  member later
      left. search.
     %2.2:  member here
      LEq: apply lit_eq_or_not to _ _ with L1 = L, L2 = var V.
      case LEq.
        %2.2.1:  equal
         search.
        %2.2.2:  not equal
         right. intros. case H6.
           %2.2.3.1:  member first
            backchain H5.
           %2.2.3.2:  member later
            backchain H4.
  %3:  member (is_true neg)
   apply IH to H2 IsL. case H3.
     %3.1:  member later
      left. search.
     %3.2:  member here
      LEq: apply lit_eq_or_not to _ _ with L1 = L, L2 = neg V.
      case LEq.
        %3.2.1:  equal
         search.
        %3.2.2:  not equal
         right. intros. case H6.
           %3.2.3.1:  member first
            backchain H5.
           %3.2.3.2:  member later
            backchain H4.
  %4:  member clause_id
   apply IH to H2 IsL. case H3.
     %4.1:  member
      search.
     %4.2:  not member
      right. intros Mem. case Mem. backchain H4.




/********************************************************************
 *                          CLAUSE CONTEXT                          *
 ********************************************************************/

/*
 * Some situations call for contexts that only contain clause
 * assignments:
 */
Define clause_context : olist -> prop by
  clause_context nil;
  nabla CID, clause_context (clause_id CID Clause::Rest) :=
     is_clause Clause /\ clause_context Rest.


Theorem clause_context_assign_context : forall Ctx,
  clause_context Ctx -> assign_context Ctx.
induction on 1. intros CC. case CC.
  %1:  nil
   search.
  %2:  clause_id
   apply IH to H2. search.


Theorem clause_context_member : forall Ctx F,
  clause_context Ctx -> member F Ctx ->
  exists CID C, F = clause_id CID C /\ is_clause C /\ name CID.
induction on 2. intros CC Mem. case Mem.
  %1:  mem here
   case CC. search.
  %2:  mem later
   case CC. backchain IH.




/********************************************************************
 *                          EXPAND CONTEXT                          *
 ********************************************************************/

/*
 * We can expand a context by adding assignments for literals, but not
 * new clauses.
 */
Define expand_context : olist -> olist -> prop by
  expand_context CC AC :=
     (forall F, member F CC -> member F AC) /\
     (forall CID C,
         member (clause_id CID C) AC -> member (clause_id CID C) CC).


Theorem expand_context_add_clause_id : forall CC AC CID C,
  expand_context CC AC ->
  expand_context (clause_id CID C::CC) (clause_id CID C::AC).
intros EC. case EC.
  %1:  all members remain
   assert (forall F, member F (clause_id CID C::CC) ->
                     member F (clause_id CID C::AC)).
     intros Mem. case Mem.
       %1.1:  mem here
        search.
       %1.2:  mem later
        apply H1 to H3. search.
  %2:  only the same clause ID's
   assert (forall InID InC,
              member (clause_id InID InC) (clause_id CID C::AC) ->
              member (clause_id InID InC) (clause_id CID C::CC)).
     intros Mem. case Mem.
       %2.1:  mem here
        search.
       %2.2:  mem later
        apply H2 to H4. search.
search.


Theorem expand_context_monotone : forall CC AC F,
  expand_context CC AC -> {CC |- F} -> {AC |- F}.
intros EC P. case EC. monotone P with AC. search.


Theorem expand_context_add_member : forall C1 C2 F,
  expand_context C1 C2 -> member F C2 -> expand_context (F::C1) C2.
intros EC MemC2. case EC.
  %all members of (F::C1) in C2
   assert forall P, member P (F::C1) -> member P C2.
     intros Mem. case Mem. search. backchain H1.
  %all clause_id member
   assert forall CID C, member (clause_id CID C) C2 ->
             member (clause_id CID C) (F::C1).
     intros Mem.apply H2 to Mem. search.
search.


Theorem expand_context_add_both : forall C1 C2 F,
  expand_context C1 C2 -> expand_context (F::C1) (F::C2).
intros EC. EC': case EC.
  %all members of (F::C!) in (F::C2)
   assert forall X, member X (F::C1) -> member X (F::C2).
     intros Mem. case Mem.
       %member first
        search.
       %member later
        apply EC' to H1. search.
  %all clause_id member
   assert forall CID C, member (clause_id CID C) (F::C2) ->
             member (clause_id CID C) (F::C1).
     intros Mem. case Mem.
       %member first
        search.
       %member later
        apply EC'1 to H2. search.
search.


Theorem expand_context_not_mem2 : forall C1 C2 F,
  expand_context C1 C2 -> (member F C2 -> false) -> member F C1 ->
  false.
intros EC NotMem Mem. EC': case EC. backchain NotMem. backchain EC'.


Theorem expand_context_transitive : forall C1 C2 C3,
  expand_context C1 C2 -> expand_context C2 C3 ->
  expand_context C1 C3.
intros A B. A': case A. B': case B.
  %all members of C1 in C3
   assert forall F, member F C1 -> member F C3.
     intros Mem. apply A' to Mem. backchain B'.
  %all clause_id members
   assert forall CID C, member (clause_id CID C) C3 ->
             member (clause_id CID C) C1.
     intros Mem. apply B'1 to Mem. backchain A'1.
search.





/********************************************************************
 *                              NEGATE                              *
 ********************************************************************/

Theorem negate_exists : forall Ctx L,
  assign_context Ctx -> is_lit L -> exists NL, {Ctx |- negate L NL}.
intros GC IsL. case IsL. search. search.


Theorem negate_no_context : forall Ctx L NL,
  assign_context Ctx -> {Ctx |- negate L NL} -> {negate L NL}.
intros GC Neg. case Neg.
  %1:  L = var
   search.
  %2:  L = neg
   search.
  %3:  context
   apply assign_context_member to GC H2. case H3. case H1. case H1.


Theorem negate_unique : forall L NL1 NL2,
  {negate L NL1} -> {negate L NL2} -> NL1 = NL2.
intros Neg1 Neg2. case Neg1.
  %1:  L = var
   case Neg2. search.
  %2:  L = neg
   case Neg2. search.


Theorem not_is_true_lit_negate : forall Ctx L NL,
  assign_context Ctx -> {Ctx |- negate L NL} ->
  {Ctx |- is_true L} -> {Ctx |- is_true NL} ->
  false.
intros GC Neg TrueL TrueNL. case TrueL.
apply assign_context_member to GC H2. case H3.
  %1:  is_true L
   apply negate_no_context to GC Neg. case TrueNL.
   apply assign_context_member to GC H7. case H8.
     %1.1:  is_true NL
      case H6. case H1.
      apply assign_context_not_member_lit_and_neg to GC H5 H2 H7.
     %1.2:  clause_id
      case H6.
  %2:  clause_id
   case H1.


Theorem negate_is_lit : forall L NL, {negate L NL} -> is_lit L.
intros Neg. case Neg. search. search.


Theorem negate_reverse : forall L NL, {negate L NL} -> {negate NL L}.
intros. case H1. search. search.




/********************************************************************
 *                          SAT AND UNSAT                           *
 ********************************************************************/

Theorem not_sat_unsat_clause : forall Ctx C,
  assign_context Ctx ->
  {Ctx |- sat_clause C} -> {Ctx |- unsat_clause C} ->
  false.
induction on 3. intros GC Sat Unsat. case Sat.
  %1:  C = or L Rest, Rest is sat
   case Unsat.
    %1.1:  unsat rule
     apply IH to _ H1 H4.
    %1.2:  context
     apply assign_context_member to GC H3. case H4.
      %1.2.1:  is_true
       case H2.
      %1.2.2:  clause_id
       case H2.
  %2:  C = or L Rest, L is true
   case Unsat.
    %2.1:  unsat rule
     apply not_is_true_lit_negate to GC H2 H1 H3.
    %2.2:  context
     apply assign_context_member to GC H3. case H4.
       %2.2.1:  is_true
        case H2.
       %2.2.2:  clause_id
        case H2.
  %3:  context
   apply assign_context_member to GC H2. case H3.
     %3.1:  is_true
      case H1.
     %3.2:  clause_id
      case H1.


Theorem sat_clause__clause_id_ctx : forall Ctx CID C C',
  assign_context Ctx -> {Ctx, clause_id CID C |- sat_clause C'} ->
  {Ctx |- sat_clause C'}.
induction on 2. intros AC P. case P.
  %1:  sat later
   apply IH to _ H1. search.
  %2:  sat here
   case H1. case H3.
     %2.1:  backchain clause_id
      case H2.
     %2.2:  backchain else
      apply assign_context_member to AC H4. case H5.
        %2.2.1:  member is_true
         case H2. search.
        %2.2.2:  member clause_id
         case H2.
  %3:  context
   case H2.
     %3.1:  member clause_id
      case H1.
     %3.2:  member rest
      apply assign_context_member to AC H3. case H4.
        %3.2.1:  member is_true
         case H1.
        %3.2.2:  member clause_id
         case H1.


Theorem sat__clause_id_ctx : forall Ctx CID C F,
  assign_context Ctx -> {Ctx, clause_id CID C |- sat F} ->
  {Ctx |- sat F}.
induction on 2. intros AC P. case P.
  %1:  f*
   search.
  %2:  and
   apply sat_clause__clause_id_ctx to AC H1. apply IH to AC H2.
   search.
  %3:  context
   case H2.
     %3.1:  member first
      case H1.
     %3.2:  member later
      apply assign_context_member to AC H3. case H4.
        %3.2.1:  member is_true
         case H1.
        %3.2.2:  member clause_id
         case H1.


Theorem empty_clause_unsat : forall Ctx,
  assign_context Ctx -> {Ctx |- sat_clause c*} -> false.
intros CC SatC. case SatC. apply assign_context_member to CC H2.
case H3. case H1. case H1.




/********************************************************************
 *                          CLAUSE MEMBER                           *
 ********************************************************************/

/*
 * Membership of a literal in a clause
 */
Define clause_member : lit -> clause -> prop by
  clause_member L (or L Rest);
  clause_member L (or X Rest) := clause_member L Rest.


Theorem clause_member_ctx_member_sat : forall Ctx L C,
  member (is_true L) Ctx -> clause_member L C ->
  {Ctx |- sat_clause C}.
induction on 2. intros Mem CMem. CMem': case CMem.
  %1:  clause_member here
   search.
  %2:  clase_member later
   apply IH to Mem CMem'. search.


Theorem clause_member_or_not : forall L C,
  is_lit L -> is_clause C ->
  clause_member L C \/ (clause_member L C -> false).
induction on 2. intros IsL IsC. IsC': case IsC.
  %1:  empty clause
   right. intros Mem. case Mem.
  %2:  add clause
   Eq: apply lit_eq_or_not to IsL IsC'. Eq': case Eq.
     %2.1:  equal
      search.
     %2.2:  not equal
      Sub: apply IH to IsL IsC'1. Sub': case Sub.
        %2.2.1:  member rest
         search.
        %2.2.2:  not member rest
         right. intros Mem. Mem': case Mem.
           %2.2.2.1:  member here
            backchain Eq'.
           %2.2.2.2:  member later
            backchain Sub'.


Theorem not_clause_member_sat_irrelevant : forall Ctx C L,
  assign_context Ctx -> {Ctx, is_true L |- sat_clause C} ->
  (clause_member L C -> false) -> {Ctx |- sat_clause C}.
induction on 2. intros AC Sat CMem. Sat': case Sat.
  %1:  sat later
   apply IH to AC Sat' _. intros CMem'. backchain CMem. search.
  %2:  sat here
   Sat'': case Sat'. Mem: case Sat''1.
     %2.1:  backchain is_true L
      case Sat''. CMemL1: assert clause_member L1 (or L1 Rest).
      apply CMem to CMemL1.
     %2.2:  backchain in Ctx
      Mem': apply assign_context_member to AC Mem. case Mem'.
        %2.2.1:  member is_true
         case Sat''. search.
        %2.2.2:  member clause_id
         case Sat''.
  %3:  context
   Mem: case Sat'1.
     %3.1:  member first is_true
      case Sat'.
     %3.2:  member Ctx
      Mem': apply assign_context_member to AC Mem. case Mem'.
        %3.2.1:  member is_true
         case Sat'.
        %3.2.2:  member clause_id
         case Sat'.




/********************************************************************
 *                           UNIT CLAUSE                            *
 ********************************************************************/

Theorem unit_clause_expand_context : forall AC C L Sat,
  assign_context AC -> {AC |- unit_clause C L} ->
  assign_context Sat -> expand_context AC Sat ->
  {Sat |- sat_clause C} ->
  member (is_true L) Sat.
induction on 2. intros AC UC ACSat EC Sat. UC: case UC.
  %1:  first lit unassigned, rest unsat
   Sat: case Sat.
     %1.1:  sat rest
      UCSat: apply expand_context_monotone to EC UC1.
      apply not_sat_unsat_clause to ACSat Sat UCSat.
     %1.2:  sat here
      case Sat. apply assign_context_member to ACSat H2. case H3.
        %1.2.1:  member is_true
         case H1. search.
        %1.2.2:  member clause_id
         case H1.
     %1.3:  context
      apply assign_context_member to ACSat Sat1. case H1.
        %1.3.1:  member is_true
         case Sat.
        %1.3.2:  member clause_id
         case Sat.
  %2:  first lit assigned false, sat from rest
   Sat: case Sat.
     %2.1:  sat rest
      backchain IH.
     %2.2:  sat here
      SatNeg: apply expand_context_monotone to EC UC.
      SatTrueNL: apply expand_context_monotone to EC UC1.
      apply not_is_true_lit_negate to ACSat SatNeg Sat SatTrueNL.
     %2.3:  context
      apply assign_context_member to ACSat Sat1. case H1.
        %2.3.1:  member is_true
         case Sat.
        %2.3.2:  member clause_id
         case Sat.
  %3:  context
   apply assign_context_member to AC UC1. case H1.
     %3.1:  member is_true
      case UC.
     %3.2:  member clause_id
      case UC.


Theorem unit_clause_not_assigned : forall AC C L,
  assign_context AC -> {AC |- unit_clause C L} ->
  {AC |- not_assigned L}.
induction on 2. intros AC UC. case UC.
  %1:  not assigned first
   search.
  %2:  not assigned later
   backchain IH.
  %3:  context
   apply assign_context_member to AC H2. case H3.
     %3.1:  member is_lit
      case H1.
     %3.2:  member clause_id
      case H1.


Theorem unit_clause_is_lit : forall AC C L,
  assign_context AC -> is_clause C -> {AC |- unit_clause C L} ->
  is_lit L.
induction on 3. intros AC IsC UC. case UC.
  %1:  not assigned first
   case IsC. search.
  %2:  not assigned later
   case IsC. apply IH to AC H5 H3. search.
  %3:  context
   apply assign_context_member to AC H2. case H3.
     %3.1:  member is_true
      case H1.
     %3.2:  member clause_id
      case H1.




/********************************************************************
 *                               RUP                                *
 ********************************************************************/

Theorem rup_help_unsat : forall AC Sat ProofList,
  %Having both rup_help (a successful proof line)
  assign_context AC -> {AC |- rup_help ProofList} ->
  %and a superset satisfying assignment
  expand_context AC Sat -> assign_context Sat ->
  (forall InID InC,
      {Sat |- clause_id InID InC} -> {Sat |- sat_clause InC}) ->
  %is impossible
  false.
induction on 2. intros AC RupHelp EC ACSat Sat. case RupHelp.
  %1:  last proof clause
   SatCID: apply expand_context_monotone to EC H1.
   SatSat: apply Sat to SatCID.
   SatUnsat: apply expand_context_monotone to EC H2.
   apply not_sat_unsat_clause to ACSat SatSat SatUnsat.
  %2:  step proof clause
   SatCID: apply expand_context_monotone to EC H1.
   SatC: apply Sat to SatCID.
   Mem: apply unit_clause_expand_context to AC H2 ACSat EC SatC.
   AddEC: apply expand_context_add_member to EC Mem.
   NAL: apply unit_clause_not_assigned to AC H2.
   IsC:  apply clause_id_is_clause to AC H1.
   IsL:  apply unit_clause_is_lit to AC IsC H2.
   ACAdd: apply assign_context_add_is_true to AC IsL NAL.
   apply IH to ACAdd H3 AddEC ACSat Sat.
  %3:  context
   apply assign_context_member to AC H2. case H3.
     %3.1:  member is_true
      case H1.
     %3.2:  member clause_id
      case H1.


/*
 * This is a lemma for rup_maintains_sat that can't be done until we have negate theorems, so it's here
 */
Theorem assign_context_expand : forall AC C L NL,
  assign_context AC -> expand_context AC C -> is_lit L ->
  {negate L NL} -> (member (is_true L) C -> false) ->
  assign_context (is_true NL::AC).
intros AC EC IsL Neg NotMem.
backchain assign_context_add_is_true_not_mem with AC = AC, NL = L.
backchain negate_reverse. EC': case EC. intros Mem. backchain NotMem.
backchain EC'.


%Sat and the clause being unsatisfied with rup_help implies false?

%Unsat clause under a context and rup_help implies sat must also satisfy that clause?  It needs to be *exactly* unsat that clause though; anything larger would mean it could be something else changed


Theorem rup_maintains_sat : forall AC1 AC2 NewClause Proof,
  %Any context with the same clauses but some more var assignments
  assign_context AC1 -> assign_context AC2 ->
  expand_context AC1 AC2 -> is_clause NewClause ->
  %that satisfies the existing clauses,
  (forall CID C, {AC2 |- clause_id CID C} -> {AC2 |- sat_clause C}) ->
  %a new clause RUP with the existing clauses
  {AC1 |- rup NewClause Proof} ->
  %will also be satisfied by the same assignment
  exists AC3, expand_context AC2 AC3 /\
              {AC3 |- sat_clause NewClause} /\ assign_context AC3.
induction on 6. intros AC1 AC2 EC IsC Sat RUP. RUP': case RUP.
  %1:  RUP empty clause
   apply rup_help_unsat to AC1 RUP' EC AC2 Sat.
  %2:  RUP or
   Is: case IsC. MemL: apply assign_context_member_or_not to AC2 Is.
   MemL': case MemL.
     %2.1:  L member of sat context (new clause sat here)
      search.
     %2.2:  L not member of sat context
      Neg: apply negate_no_context to _ RUP'.
      NewAC: apply assign_context_expand to AC1 EC Is Neg MemL'.
      Neg: apply negate_no_context to AC1 RUP'.
      NegR: apply negate_reverse to Neg.
      IsNL: apply negate_is_lit to NegR.
      MemNL: apply assign_context_member_or_not to AC2 IsNL.
      MemNL': case MemNL.
        %2.2.1:  NL member of sat context
         NewEC: apply expand_context_add_member to EC MemNL'.
         apply IH to NewAC AC2 NewEC Is1 Sat RUP'1. search.
        %2.2.2:  NL not member of sat context
         NewEC: apply expand_context_add_both to EC
                   with F = is_true NL.
         NewAC2: apply assign_context_add_is_true_not_mem to
                    AC2 _ MemL'.
         NewSat: assert forall CID C,
                           {AC2, is_true NL |- clause_id CID C} ->
                           {AC2, is_true NL |- sat_clause C}.
            intros CID. CID': case CID. case CID'1.
              %member first
               case CID'.
              %member later
               apply assign_context_member to AC2 H1. case H2.
                 %member is_true
                  case CID'.
                 %member clause_id
                  case CID'. CID2: assert {AC2 |- clause_id CID C}.
                  ShortSat: apply Sat to CID2.
                  monotone ShortSat with (is_true NL::AC2). search.
         apply IH to NewAC NewAC2 NewEC Is1 NewSat RUP'1.
         EC3: assert expand_context AC2 AC3. skip. search.
  %3:  context
   apply assign_context_member to AC1 RUP'1. case H1.
     %3.1:  member is_true
      case RUP'.
     %3.2:  member clause_id
      case RUP'.




/********************************************************************
 *                           CHECK PROOF                            *
 ********************************************************************/

Theorem check_proof_correct : forall CC ProofList AC,
  is_proof ProofList ->
  %The unsat proof checks out
  clause_context CC -> {CC |- check_proof ProofList} ->
  %and there is a satisfying assignment for the existing clauses---
  assign_context AC -> expand_context CC AC ->
  (forall CID C, {AC |- clause_id CID C} -> {AC |- sat_clause C}) ->
  %this is impossible
  false.
induction on 3. intros IsP CC Check AC EC Sat. case Check.
  %1:  end proof
   CCAC: apply clause_context_assign_context to CC.
   RUPRes: apply rup_maintains_sat to CCAC AC EC _ Sat H1.
   apply empty_clause_unsat to RUPRes2 RUPRes1.
  %2:  step proof
   Is': case IsP.
   CCAC: apply clause_context_assign_context to CC.
   RUPRes: apply rup_maintains_sat to CCAC AC EC Is' Sat H1.
   NewCC: assert clause_context (clause_id n1 C::CC).
   NewAC: assert assign_context (clause_id n1 C::AC3).
   EC_CC_AC3: apply expand_context_transitive to EC RUPRes.
   NewEC: apply expand_context_add_both to EC_CC_AC3 with
             F = clause_id n1 C.
   Sub: apply IH to Is'1 NewCC H2 NewAC NewEC _. intros ExClauseID.
   ECI: case ExClauseID. Mem: case ECI1.
     %2.1:  mem here
      case ECI. monotone RUPRes1 with (clause_id n1 C1::AC3). search.
     %2.2:  mem later
      Mem': apply assign_context_member to RUPRes2 Mem. case Mem'.
        %2.2.1:  mem is_true
         case ECI.
        %2.2.2:  mem clause_id
         case ECI. AC3CID: assert {AC3 |- clause_id (CID n1) C1}.
         ECCond: case RUPRes (keep). MemAC: apply ECCond1 to Mem.
         ACCID: assert {AC |- clause_id (CID n1) C1}.
         ACSat: apply Sat to ACCID.
         AC3Sat: apply expand_context_monotone to RUPRes ACSat.
         monotone AC3Sat with (clause_id n1 C::AC3). search.
  %3:  context
   apply clause_context_member to CC H2. case H1.

