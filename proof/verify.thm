Specification "proof".


/********************************************************************
 *                           ASSUMPTIONS                            *
 ********************************************************************/

/*
 * We can't prove anything about not_assigned because it uses cut and
 * fail, so we assume it works.
 */
Theorem not_assigned_true_lit : forall Ctx L,
  {Ctx |- not_assigned L} -> member (is_true L) Ctx -> false.
skip.
Theorem not_assigned_false_lit : forall Ctx L NL,
  {Ctx |- not_assigned L} -> {negate L NL} ->
  member (is_true NL) Ctx -> false.
skip.




/********************************************************************
 *                           IS RELATIONS                           *
 ********************************************************************/

/*
 * Define type relations
 */
Define is_lit : lit -> prop by
  is_lit (var V);
  is_lit (neg V).

Define is_clause : clause -> prop by
  is_clause c*;
  is_clause (or L Rest) := is_lit L /\ is_clause Rest.

Define is_formula : formula -> prop by
  is_formula f*;
  is_formula (and C Rest) := is_clause C /\ is_formula Rest.

Define is_proof : proof -> prop by
  is_proof (p* PL);
  is_proof (add_line C PL AbsRest) :=
    is_clause C /\ nabla x, is_proof (AbsRest x).




/********************************************************************
 *                          NAME AND NABLA                          *
 ********************************************************************/

Define name : clause_id -> prop by
  nabla x, name x.

Theorem nabla_not_member : forall C L, nabla x,
  member (clause_id x C) L -> false.
induction on 1. intros Mem. case Mem. backchain IH.

/*
 * We need to close some terms so we know nominal constants of one
 * type cannot occur inside others.
 */
Close var, clause_id, lit, clause.




/********************************************************************
 *                          ASSIGN CONTEXT                          *
 ********************************************************************/

/*
 * A good context contains is_true and clause_id
 * A good context contains at most is_true of A or -A, not both
 * A good context contains at most ONE binding for a clause ID
 */
Define assign_context : olist -> prop by
  assign_context nil;
  assign_context (is_true (var V)::Rest) :=
     (member (is_true (neg V)) Rest -> false) /\
     assign_context Rest;
  assign_context (is_true (neg V)::Rest) :=
     (member (is_true (var V)) Rest -> false) /\
     assign_context Rest;
  nabla CID, assign_context (clause_id CID Clause::Rest) :=
     is_clause Clause /\ assign_context Rest.


Theorem assign_context_member : forall Ctx F,
  assign_context Ctx -> member F Ctx ->
  (exists L, is_lit L /\ F = is_true L) \/
  (exists CID C, is_clause C /\ F = clause_id CID C /\ name CID).
induction on 2. intros GC Mem. case Mem.
  %1:  Member here
   case GC.
    %1.1:  F = is_true (neg V)
     search.
    %1.2:  F = is_true (var V)
     search.
    %1.3:  F = clause_id CID Clause
     search.
  %2:  Member later
   case GC.
    %2.1:  First is_true neg
     apply IH to H3 H1. search.
    %2.2:  First is_true var
     apply IH to H3 H1. search.
    %2.3:  First clause_id
     apply IH to H3 H1. search.


Theorem assign_context_not_member_lit_and_neg : forall Ctx L NL,
  assign_context Ctx -> {negate L NL} ->
  member (is_true L) Ctx -> member (is_true NL) Ctx ->
  false.
induction on 1. intros GC Neg MemL MemNL. case GC (keep).
  %1:  nil Ctx
   case MemL.
  %2:  is_true var
   case MemL.
     %2.1:  mem here (L = var V)
      case Neg. case MemNL. backchain H1.
     %2.2:  mem later
      case MemNL.
        %2.2.1:  mem here (NL = var V)
         case Neg (keep). backchain H1.
        %2.2.2:  mem later
         apply IH to H2 Neg H3 H4.
  %3:  is_true neg
   case MemL.
     %3.1:  mem here (L = neg V)
      case Neg. case MemNL. backchain H1.
     %3.2:  mem later
      case MemNL.
        %3.2.1:  mem here (NL = neg V)
         case Neg. backchain H1.
        %3.2.2:  mem later
         backchain IH.
  %4:  clause_id
   case MemL. case MemNL. backchain IH.


Theorem assign_context_add_is_true : forall AC L,
  assign_context AC -> is_lit L -> {AC |- not_assigned L} ->
  assign_context (is_true L::AC).
intros AC IsL NA. case IsL.
  %1:  var V
   assert member (is_true (neg V)) AC -> false.
     intros Mem. Neg: assert {negate (var V) (neg V)}.
     apply not_assigned_false_lit to NA Neg Mem.
   search.
  %2:  neg V
   assert member (is_true (var V)) AC -> false.
     intros Mem. Neg: assert {negate (neg V) (var V)}.
     apply not_assigned_false_lit to NA Neg Mem.
   search.


Theorem clause_id_is_clause : forall AC CID C,
  assign_context AC -> {AC |- clause_id CID C} -> is_clause C.
intros AC ClauseID. case ClauseID.
apply assign_context_member to AC H2. case H3.
  %1:  member is_true
   case H1.
  %2:  member clause_id
   case H1. search.


Theorem clause_id_unique : forall AC CID C1 C2,
  assign_context AC -> member (clause_id CID C1) AC ->
  member (clause_id CID C2) AC -> C1 = C2.
induction on 2. intros AC Mem1 Mem2. case Mem1.
  %1:  mem 1 here
   case Mem2.
     %1.1:  mem 2 here
      search.
     %1.2:  mem 2 later
      case AC. apply nabla_not_member to H1.
  %2:  mem 1 later
   case Mem2.
     %2.1:  mem 2 here
      case AC. apply nabla_not_member to H1.
     %2.2:  mem 2 later
      backchain IH with AC = L. case AC. search. search. search.




/********************************************************************
 *                          CLAUSE CONTEXT                          *
 ********************************************************************/

/*
 * Some situations call for contexts that only contain clause
 * assignments:
 */
Define clause_context : olist -> prop by
  clause_context nil;
  nabla CID, clause_context (clause_id CID Clause::Rest) :=
     is_clause Clause /\ clause_context Rest.


Theorem clause_context_assign_context : forall Ctx,
  clause_context Ctx -> assign_context Ctx.
induction on 1. intros CC. case CC.
  %1:  nil
   search.
  %2:  clause_id
   apply IH to H2. search.


Theorem clause_context_member : forall Ctx F,
  clause_context Ctx -> member F Ctx ->
  exists CID C, F = clause_id CID C /\ is_clause C /\ name CID.
induction on 2. intros CC Mem. case Mem.
  %1:  mem here
   case CC. search.
  %2:  mem later
   case CC. backchain IH.




/********************************************************************
 *                          EXPAND CONTEXT                          *
 ********************************************************************/

/*
 * We can expand a context by adding assignments for literals, but not
 * new clauses.
 */
Define expand_context : olist -> olist -> prop by
  expand_context CC AC :=
     (forall F, member F CC -> member F AC) /\
     (forall CID C,
         member (clause_id CID C) AC -> member (clause_id CID C) CC).


Theorem expand_context_add_clause_id : forall CC AC CID C,
  expand_context CC AC ->
  expand_context (clause_id CID C::CC) (clause_id CID C::AC).
intros EC. case EC.
  %1:  all members remain
   assert (forall F, member F (clause_id CID C::CC) ->
                     member F (clause_id CID C::AC)).
     intros Mem. case Mem.
       %1.1:  mem here
        search.
       %1.2:  mem later
        apply H1 to H3. search.
  %2:  only the same clause ID's
   assert (forall InID InC,
              member (clause_id InID InC) (clause_id CID C::AC) ->
              member (clause_id InID InC) (clause_id CID C::CC)).
     intros Mem. case Mem.
       %2.1:  mem here
        search.
       %2.2:  mem later
        apply H2 to H4. search.
search.


Theorem expand_context_monotone : forall CC AC F,
  expand_context CC AC -> {CC |- F} -> {AC |- F}.
intros EC P. case EC. monotone P with AC. search.


Theorem expand_context_add_member : forall C1 C2 F,
  expand_context C1 C2 -> member F C2 -> expand_context (F::C1) C2.
intros EC MemC2. case EC.
  %all members of (F::C1) in C2
   assert forall P, member P (F::C1) -> member P C2.
     intros Mem. case Mem. search. backchain H1.
  %all clause_id member
   assert forall CID C, member (clause_id CID C) C2 ->
             member (clause_id CID C) (F::C1).
     intros Mem.apply H2 to Mem. search.
search.




/********************************************************************
 *                              NEGATE                              *
 ********************************************************************/

Theorem negate_exists : forall Ctx L,
  assign_context Ctx -> is_lit L -> exists NL, {Ctx |- negate L NL}.
intros GC IsL. case IsL. search. search.


Theorem negate_no_context : forall Ctx L NL,
  assign_context Ctx -> {Ctx |- negate L NL} -> {negate L NL}.
intros GC Neg. case Neg.
  %1:  L = var
   search.
  %2:  L = neg
   search.
  %3:  context
   apply assign_context_member to GC H2. case H3. case H1. case H1.


Theorem negate_unique : forall L NL1 NL2,
  {negate L NL1} -> {negate L NL2} -> NL1 = NL2.
intros Neg1 Neg2. case Neg1.
  %1:  L = var
   case Neg2. search.
  %2:  L = neg
   case Neg2. search.


Theorem not_is_true_lit_negate : forall Ctx L NL,
  assign_context Ctx -> {Ctx |- negate L NL} ->
  {Ctx |- is_true L} -> {Ctx |- is_true NL} ->
  false.
intros GC Neg TrueL TrueNL. case TrueL.
apply assign_context_member to GC H2. case H3.
  %1:  is_true L
   apply negate_no_context to GC Neg. case TrueNL.
   apply assign_context_member to GC H7. case H8.
     %1.1:  is_true NL
      case H6. case H1.
      apply assign_context_not_member_lit_and_neg to GC H5 H2 H7.
     %1.2:  clause_id
      case H6.
  %2:  clause_id
   case H1.


Theorem negate_is_lit : forall L NL, {negate L NL} -> is_lit L.
intros Neg. case Neg. search. search.




/********************************************************************
 *                          SAT AND UNSAT                           *
 ********************************************************************/

Theorem not_sat_unsat_clause : forall Ctx C,
  assign_context Ctx ->
  {Ctx |- sat_clause C} -> {Ctx |- unsat_clause C} ->
  false.
induction on 3. intros GC Sat Unsat. case Sat.
  %1:  C = or L Rest, Rest is sat
   case Unsat.
    %1.1:  unsat rule
     apply IH to _ H1 H4.
    %1.2:  context
     apply assign_context_member to GC H3. case H4.
      %1.2.1:  is_true
       case H2.
      %1.2.2:  clause_id
       case H2.
  %2:  C = or L Rest, L is true
   case Unsat.
    %2.1:  unsat rule
     apply not_is_true_lit_negate to GC H2 H1 H3.
    %2.2:  context
     apply assign_context_member to GC H3. case H4.
       %2.2.1:  is_true
        case H2.
       %2.2.2:  clause_id
        case H2.
  %3:  context
   apply assign_context_member to GC H2. case H3.
     %3.1:  is_true
      case H1.
     %3.2:  clause_id
      case H1.


Theorem sat_clause__clause_id_ctx : forall Ctx CID C C',
  assign_context Ctx -> {Ctx, clause_id CID C |- sat_clause C'} ->
  {Ctx |- sat_clause C'}.
induction on 2. intros AC P. case P.
  %1:  sat later
   apply IH to _ H1. search.
  %2:  sat here
   case H1. case H3.
     %2.1:  backchain clause_id
      case H2.
     %2.2:  backchain else
      apply assign_context_member to AC H4. case H5.
        %2.2.1:  member is_true
         case H2. search.
        %2.2.2:  member clause_id
         case H2.
  %3:  context
   case H2.
     %3.1:  member clause_id
      case H1.
     %3.2:  member rest
      apply assign_context_member to AC H3. case H4.
        %3.2.1:  member is_true
         case H1.
        %3.2.2:  member clause_id
         case H1.


Theorem sat__clause_id_ctx : forall Ctx CID C F,
  assign_context Ctx -> {Ctx, clause_id CID C |- sat F} ->
  {Ctx |- sat F}.
induction on 2. intros AC P. case P.
  %1:  f*
   search.
  %2:  and
   apply sat_clause__clause_id_ctx to AC H1. apply IH to AC H2.
   search.
  %3:  context
   case H2.
     %3.1:  member first
      case H1.
     %3.2:  member later
      apply assign_context_member to AC H3. case H4.
        %3.2.1:  member is_true
         case H1.
        %3.2.2:  member clause_id
         case H1.


Theorem empty_clause_unsat : forall Ctx,
  assign_context Ctx -> {Ctx |- sat_clause c*} -> false.
intros CC SatC. case SatC. apply assign_context_member to CC H2.
case H3. case H1. case H1.




/********************************************************************
 *                           UNIT CLAUSE                            *
 ********************************************************************/

Theorem unit_clause_expand_context : forall AC C L Sat,
  assign_context AC -> {AC |- unit_clause C L} ->
  assign_context Sat -> expand_context AC Sat ->
  {Sat |- sat_clause C} ->
  member (is_true L) Sat.
induction on 2. intros AC UC ACSat EC Sat. UC: case UC.
  %1:  first lit unassigned, rest unsat
   Sat: case Sat.
     %1.1:  sat rest
      UCSat: apply expand_context_monotone to EC UC1.
      apply not_sat_unsat_clause to ACSat Sat UCSat.
     %1.2:  sat here
      case Sat. apply assign_context_member to ACSat H2. case H3.
        %1.2.1:  member is_true
         case H1. search.
        %1.2.2:  member clause_id
         case H1.
     %1.3:  context
      apply assign_context_member to ACSat Sat1. case H1.
        %1.3.1:  member is_true
         case Sat.
        %1.3.2:  member clause_id
         case Sat.
  %2:  first lit assigned false, sat from rest
   Sat: case Sat.
     %2.1:  sat rest
      backchain IH.
     %2.2:  sat here
      SatNeg: apply expand_context_monotone to EC UC.
      SatTrueNL: apply expand_context_monotone to EC UC1.
      apply not_is_true_lit_negate to ACSat SatNeg Sat SatTrueNL.
     %2.3:  context
      apply assign_context_member to ACSat Sat1. case H1.
        %2.3.1:  member is_true
         case Sat.
        %2.3.2:  member clause_id
         case Sat.
  %3:  context
   apply assign_context_member to AC UC1. case H1.
     %3.1:  member is_true
      case UC.
     %3.2:  member clause_id
      case UC.


Theorem unit_clause_not_assigned : forall AC C L,
  assign_context AC -> {AC |- unit_clause C L} ->
  {AC |- not_assigned L}.
induction on 2. intros AC UC. case UC.
  %1:  not assigned first
   search.
  %2:  not assigned later
   backchain IH.
  %3:  context
   apply assign_context_member to AC H2. case H3.
     %3.1:  member is_lit
      case H1.
     %3.2:  member clause_id
      case H1.


Theorem unit_clause_is_lit : forall AC C L,
  assign_context AC -> is_clause C -> {AC |- unit_clause C L} ->
  is_lit L.
induction on 3. intros AC IsC UC. case UC.
  %1:  not assigned first
   case IsC. search.
  %2:  not assigned later
   case IsC. apply IH to AC H5 H3. search.
  %3:  context
   apply assign_context_member to AC H2. case H3.
     %3.1:  member is_true
      case H1.
     %3.2:  member clause_id
      case H1.




/********************************************************************
 *                               RUP                                *
 ********************************************************************/

Theorem rup_help_unsat : forall AC Sat ProofList,
  %Having both rup_help (a successful proof line)
  assign_context AC -> {AC |- rup_help ProofList} ->
  %and a superset satisfying assignment
  expand_context AC Sat -> assign_context Sat ->
  (forall InID InC,
      {Sat |- clause_id InID InC} -> {Sat |- sat_clause InC}) ->
  %is impossible
  false.
induction on 2. intros AC RupHelp EC ACSat Sat. case RupHelp.
  %1:  last proof clause
   SatCID: apply expand_context_monotone to EC H1.
   SatSat: apply Sat to SatCID.
   SatUnsat: apply expand_context_monotone to EC H2.
   apply not_sat_unsat_clause to ACSat SatSat SatUnsat.
  %2:  step proof clause
   SatCID: apply expand_context_monotone to EC H1.
   SatC: apply Sat to SatCID.
   Mem: apply unit_clause_expand_context to AC H2 ACSat EC SatC.
   AddEC: apply expand_context_add_member to EC Mem.
   NAL: apply unit_clause_not_assigned to AC H2.
   IsC:  apply clause_id_is_clause to AC H1.
   IsL:  apply unit_clause_is_lit to AC IsC H2.
   ACAdd: apply assign_context_add_is_true to AC IsL NAL.
   apply IH to ACAdd H3 AddEC ACSat Sat.
  %3:  context
   apply assign_context_member to AC H2. case H3.
     %3.1:  member is_true
      case H1.
     %3.2:  member clause_id
      case H1.


Theorem rup_maintains_sat : forall CC AC NewClause Proof,
  %Any context with the same clauses but some var assignments
  clause_context CC -> assign_context AC -> expand_context CC AC ->
  %that satisfies the existing clauses,
  (forall CID C, {AC |- clause_id CID C} -> {AC |- sat_clause C}) ->
  %a new clause RUP with the existing clauses
  {CC |- rup NewClause Proof} ->
  %will also be satisfied by the same assignment
  {AC |- sat_clause NewClause}.
skip.




/********************************************************************
 *                           CHECK PROOF                            *
 ********************************************************************/

Theorem check_proof_correct : forall CC ProofList AC,
  is_proof ProofList ->
  %The unsat proof checks out
  clause_context CC -> {CC |- check_proof ProofList} ->
  %and there is a satisfying assignment for the existing clauses---
  assign_context AC -> expand_context CC AC ->
  (forall CID C, {AC |- clause_id CID C} -> {AC |- sat_clause C}) ->
  %this is impossible
  false.
induction on 3. intros IsP CC Check AC EC Sat. case Check.
  %1:  end proof
   apply rup_maintains_sat to CC AC EC Sat H1.
   apply empty_clause_unsat to AC H2.
  %2:  step proof
   apply rup_maintains_sat to CC AC EC Sat H1.
   NewEC: apply expand_context_add_clause_id to EC with
             CID = n1, C = C.
   IsC:  assert is_clause C. skip.
   NewCC: assert clause_context (clause_id n1 C::CC).
   ACNoClause: apply expand_context_monotone to EC H1.
   NewAC: assert assign_context (clause_id n1 C::AC).
   IsP': case IsP.
   apply IH to IsP'1 NewCC H2 NewAC NewEC _. intros ExClauseID.
   case ExClauseID. case H5.
     %2.1:  mem here
      case H4. skip.
     %2.2:  mem later
      apply assign_context_member to AC H6. case H7.
        %2.2.1:  member is_true
         case H4.
        %2.2.2:  member clause_id
         case H4. ACCID: assert {AC |- clause_id (CID n1) C1}.
         ACSatClause: apply Sat to ACCID.
         monotone ACSatClause with (clause_id n1 C::AC). search.
  %3:  context
   apply clause_context_member to CC H2. case H1.

